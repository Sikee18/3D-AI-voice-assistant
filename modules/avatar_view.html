<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: transparent;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            outline: none;
        }
    </style>
    <!-- Import Maps -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // CONFIG
        const CONFIG = {
            // REPLACE THIS: "Jimmy.glb" is your 3D Dog Model.
            // You can overwrite assets/Jimmy.glb with ANY free rigged character.
            AVATAR_URL: "../assets/Jimmy.glb",
            CAMERA_POS: { x: 0, y: 1.5, z: 3.5 }
        };

        let scene, camera, renderer, mixer;
        let actions = {};
        let currentAction = null;
        let tailBone = null, neckBone = null, spineBone = null;
        let currentState = 'idle';
        const clock = new THREE.Clock();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = null;

            // Camera - Casual Dog View (Eye Level)
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(CONFIG.CAMERA_POS.x, CONFIG.CAMERA_POS.y, CONFIG.CAMERA_POS.z);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Lights - Bright, warm studio lighting
            const ambient = new THREE.AmbientLight(0xffffff, 1.0);
            scene.add(ambient);

            const direct = new THREE.DirectionalLight(0xffedd9, 1.5); // Warm sun
            direct.position.set(2, 5, 5);
            scene.add(direct);

            // Load Avatar
            const loader = new GLTFLoader();
            loader.load(CONFIG.AVATAR_URL, (gltf) => {
                const model = gltf.scene;

                // TRANSFORM: Auto-Scale & Center for ANY Model
                const box = new THREE.Box3().setFromObject(model);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());

                // Auto-Center: Move model so its center is at (0,0,0)
                model.position.x += (model.position.x - center.x);
                model.position.y += (model.position.y - center.y) - 0.5; // Lower by 0.5 units
                model.position.z += (model.position.z - center.z);

                // ORIENTATION FIX:
                // Most models face +Z or -Z. If yours faces Right (+X), we rotate -90 deg (or 270 deg).
                // Let's try rotating it to face Camera.
                model.rotation.y = -Math.PI / 2;

                // Auto-Scale: Fit to height ~2.0 units
                const maxDim = Math.max(size.x, size.y, size.z);
                const scaleFactor = 2.0 / maxDim;
                model.scale.set(scaleFactor, scaleFactor, scaleFactor);

                console.log("Auto-Scaled Model:", scaleFactor);

                // FIND BONES (Universal Search) - Expanded for Body Dance
                console.log("--- BONE SEARCH ---");
                model.traverse((o) => {
                    if (o.isBone) {
                        const n = o.name.toLowerCase();
                        if (!tailBone && (n.includes('tail'))) {
                            tailBone = o;
                            console.log("Found Tail:", o.name);
                        }
                        if (!neckBone && (n.includes('neck') || n.includes('head'))) {
                            neckBone = o;
                            console.log("Found Head/Neck:", o.name);
                        }
                        if (!spineBone && (n.includes('spine') || n.includes('hips') || n.includes('pelvis') || n.includes('root'))) {
                            spineBone = o;
                            console.log("Found Spine/Root:", o.name);
                        }
                    }
                    // Lighting Fix: Ensure materials are visible
                    if (o.isMesh && o.material) {
                        o.material.side = THREE.DoubleSide; // Fix invisible backfaces
                        o.material.needsUpdate = true;
                    }
                });
                console.log("-------------------");

                scene.add(model);

                // Reset Camera to standard view
                camera.position.set(0, 1.2, 3.5);
                camera.lookAt(0, 0, 0);

                mixer = new THREE.AnimationMixer(model);
                const clips = gltf.animations;

                // If animations exist, use them. If not, we have procedural backup.
                clips.forEach(clip => {
                    actions[clip.name.toLowerCase()] = mixer.clipAction(clip);
                });

                setState('idle');
                animate();

            }, undefined, (e) => console.error(e));

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            if (mixer) mixer.update(dt);

            // --- PROCEDURAL ANIMATIONS (Universal) ---
            const time = Date.now() * 0.001; // Seconds

            // 1. TAIL WAG (Happy/Talk/Dance)
            if (tailBone && (currentState.includes('wag') || currentState.includes('happy') || currentState.includes('dance') || currentState.includes('talk'))) {
                let speed = 12;
                let amp = 0.5;
                if (currentState.includes('dance')) { speed = 18; amp = 0.8; }

                // Main wag (Side-to-Side) usually around Y or Z depending on bone. 
                // Trying composite rotation for maximum "wag".
                tailBone.rotation.y = Math.sin(time * speed) * amp;
                tailBone.rotation.z = Math.cos(time * speed) * (amp * 0.5);
            }

            // 2. HEAD JAM (Music)
            if (neckBone && currentState.includes('dance')) {
                neckBone.rotation.x = Math.abs(Math.sin(time * 8)) * 0.3; // Bob
                neckBone.rotation.z = Math.sin(time * 4) * 0.2; // Tilt
            }

            // 3. BODY BOUNCE (Dance) - DISABLED by User Request
            /*
            if (spineBone && currentState.includes('dance')) {
                // Bounce Up/Down
                spineBone.position.y += Math.sin(time * 15) * 0.005;
            }
            */

            // 4. BREATHE (Idle)
            if (neckBone && currentState === 'idle') {
                neckBone.rotation.x = Math.sin(time * 1.5) * 0.05;
            }

            renderer.render(scene, camera);
        }

        // Global functions for Python to call (Strict API Compliance)
        window.setIdle = function () { setState('idle'); };
        window.wagTail = function () { setState('wag'); };
        window.dance = function () { setState('dance'); };

        window.setState = function (stateName) {
            console.log("Setting state:", stateName);
            currentState = stateName.toLowerCase(); // Track for procedural loop
            const s = currentState;

            // ... (Existing animation clip logic) ...
            let clipName = 'survey';
            // If no clips exist, this part just does nothing/warnings, which is fine.
            // Our procedural loop above handles the movement!

            // Try to map to known animations if they exist
            if (s.includes('dance')) clipName = 'run';
            else if (s.includes('wag') || s.includes('talk')) clipName = 'walk';
            else clipName = 'survey'; // idle

            const newAction = actions[clipName];
            if (newAction) {
                if (newAction !== currentAction) {
                    if (currentAction) currentAction.fadeOut(0.5);
                    newAction.reset().fadeIn(0.5).play();
                    currentAction = newAction;
                }
            }
        };

        init();
    </script>
</body>

</html>